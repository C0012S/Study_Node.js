var http = require('http');

var server = http.createServer();

var host = '192.168.0.107';
var port = 3000;
server.listen(port, host, 50000, function() {
    console.log('웹 서버 실행됨.');
});

server.on('connection', function(socket) { // connection은 클라이언트가 접속할 때고, 그러면 내부적으로 소켓이라는 게 만들어진다. → 소켓을 파라미터로 전달해 준다.
    console.log('클라이언트가 접속했습니다.') // 소켓이 파라미터로 전달되면, 소켓이 접속됐다는 것을 출력한다.
    // 클라이언트가 접속했을 때, 클라이언트의 IP와 포트를 확인할 수 있다. → 소켓에서 address를 참조하면 된다.
}); // server 객체에 on이라는 함수가 있다. // server 객체가 EventEmitter를 상속한다. // connection이라는 이벤트가 발생했을 때, 콜백 함수를 실행한다.

server.on('request', function(req, res) { // req와 res 객체를 파라미터로 전달받을 수 있다. // 이거는 클라이언트가 요청하는 경우다. // 요청이 들어오면 req와 res 객체를 전달하는데, req는 요청 객체, res는 응답 객체다. 그래서 응답을 보낼 수가 있다.
    console.log('클라이언트 요청이 들어왔습니다.');
    // console.dir(req);
    
    res.writeHead(200, {"Content-Type":"text/html;charset=utf-8"}); // 응답은 res 객체의 3 가지 메소드를 생각해 보면 된다. // writeHead : http에는 헤더 정보가 있고, 실제 바디 안에 넣어서 보내는 데이터가 있을 수 있다. 헤더 정보를 클라이언트 쪽으로 출력하는 것이다. 결국에는 전송해 주는 것이다. // 200은 정상을 의미한다. // Content-Type이라는 헤더가 있다. // http는 표준이다. 표준 헤더가 있다. // text/html은 html 파일을 전송하겠다는 것이다. 이게 헤더 정보가 된다.
    res.write('<h1>웹 서버로부터 받은 응답</h1>'); // 제목 같은 것을 기록할 때 h1 태그를 사용한다.
    res.end(); // end 메소드 호출 - 이때 전송하게 된다. // 결국 write라고 하는 게, 실제 웹 페이지의 내용을 응답으로 보내 주겠다는 얘기가 되겠다.
}); // request 이벤트를 받아 볼 수 있다.

// 닫았다는 의미의 close 이벤트도 있다.

// 실행 → localhost:3000은 안 되고 IP 주소:3000으로 접속하면 결과가 출력된다.
// 웹 브라우저는 한 번만 요청하는 게 아니라 여러 번 요청할 수도 있다. // 요청이 들어왔다는 건 connection 이벤트가 발생했고 request 이벤트도 발생했다는 것이다. → 그때 req를 찍어 봤더니, 엄청나게 많은 정보가 있다. // 그래서 이런 정보들을 클라이언트에 요청이 들어오면 만들어 주는 것이다. http 모듈이 만들어서 필요한 정보를 참조한 다음에 쓸 수 있도록 지원해 준 것이다.

// 이렇게 요청 객체와 응답 객체를 request 안에서 알았으니까 이제 응답을 한 번 보내보자는 것이다.
// 실행 후 접속하면, h1 태그를 이용해서 보낸 웹 페이지 정보가 그대로 보인다. // 실제로 눈에는 안 보이지만, 헤더 정보에는 writeHead로 적은 정보가 포함돼서 전송이 된다.

// http 모듈을 이용해서 웹 서버를 만들어 봤고, 실제 웹 브라우저에서 접속도 해 봤다.
// 이게 적은 편이다. 제대로 처리하려면 이거보다 훨씬 더 많아질 것이다. // Node.js는 상당히 많은 부분을 많은 사람들이 다양한 모듈로 만들어 놓았다. // 그래서 웹 서버를 구성할 때도 다른 사람들이 만든 그런 기능들을 이용해서 구성하면 된다.
